13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231
----
## 秘密の規則
数列を生成する関数look_and_say()の引数をnとする.
look_and_say(n)はlook_and_say(n-1)の戻り値に対して
「連続する数字の個数」と「その数字」を並べる，という変換作業を施した答えである．

## 実装方法
プログラムの基本構成は関数translate_sequenceと関数look_and_sayから成る．
前者は入力文字列を，数列の生成ルールに従って変換するものである．
後者は引数(今回の標準入力)の回数だけtranslate_sequenceを繰り返す．

よって，例えば入力が'3'のとき，
translate_sequence(translate_sequence(translate_sequence('1')))
を実行するように設計した．


## 工夫した点
問題文にも記されていたように，n=10000のとき，膨大な桁数に膨れ上がり計算できなかった．
理由は，出力される文字列の桁数が入力に対して指数関数的に増加するからである．

そこで，n=10000において出力される答えの先頭500桁を正確に得るためには，
n=9999の結果のうち何桁を知っておけば良いかを考える必要がある．

n=10000の出力される答えを２つずつ区切って
10000 => |**|**|**|**|**|**|**|**|**|**|**|**|**|**|**| ......(250組)

また，look_and_sayが返す文字列に存在する「4以上の整数は発生しない」法則に着目する．（証明略）
9999 	 10000
1 	=> |11|
2 	=> |12|
3 	=> |13|
11 	=> |21|
22 	=> |22|
33 	=> |23|
111 => |31|
222 => |32|
333 => |33|

以上の組み合わせより，先頭500文字を生成する文字列の長さの期待値は500であり，最長でも750文字である・
つまり，n=9999のおよそ500文字さえ分かっていれば，n=10000は計算可能である．
同様の議論がn=9998以下でも可能であり，n=1から先頭の500文字分のみを計算することでn=10000における答えが得られる．
ただし，あくまで500文字というのは期待値であるため，念のため最悪値の750文字分計算することにした．


## 発生した問題と解決法
当初はコードを簡潔化するために関数look_and_say()を再起関数として実装していた．
しかし，Pythonの再起上限回数に引っ掛かり実行できなかった．
（発生したエラー：'RuntimeError: maximum recursion depth exceeded while getting the str of an object'）
上限回数を変更し，10000回の再起ネストが可能になるようにトライしたが，強制終了する結果となった．
最終的には，入力文字回数分ループさせるという無難な実装にした．

## 難しかった箇所
何文字分が計算に必要であるか，という問題について考えることが一番の課題であった．
